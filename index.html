<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ひとり時間の共有空間</title>
  <style>
    :root {
      /* ── テーマ色（静穏：薄いグレー系・控えめ） ─────────────── */
      --bg0: #f4f6f8;  /* 上部：ほぼ白に近い薄グレー */
      --bg1: #e8ecef;  /* 中間：少し濃い */
      --bg2: #c5ccd2;  /* 下部：さらに濃い */
      --water-tint: #bfc7cf22; /* 水面の淡い色味（透明） */

      /* リップル色（雨の色）。初期は落ち着いたグレー */
      --ripple-stroke: #5d6b7a; 
      --ripple-highlight: #5d6b7a22; /* 内側の淡い光彩（任意） */

      /* リップルの残像フェード量（0.12〜0.28推奨）。数値↑で尾が短くなる */
      --trail-opacity: 0.18;

      /* ぼかし（視覚のやわらかさ）。0〜2px 程度 */
      --blur: 0.0;
    }

    html, body { height: 100%; margin: 0; }

    /* 背景：上から下へ穏やかなグレーのグラデーション（池を俯瞰する雰囲気に） */
    body {
      background: linear-gradient(180deg, var(--bg0) 0%, var(--bg0) 70%, var(--bg1) 80%, var(--bg2) 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Hiragino Kaku Gothic ProN", Meiryo, "Noto Sans JP", sans-serif;
      color: #222;
    }

    /* 水面を描くキャンバス（全面固定） */
    .pond {
      position: fixed;
      inset: 0;
      z-index: 0;
      filter: blur(var(--blur));
    }

    /* デモ用の前景（実装時は置き換え／削除OK） */
    .content { position: relative; min-height: 100%; display: grid; place-items: center; padding: 6vmin 4vmin; }
    .card { max-width: 860px; width: min(92vw, 860px); background: #ffffffd9; border: 1px solid #e6e8eb; border-radius: 20px; padding: clamp(18px, 4vmin, 36px); box-shadow: 0 20px 40px rgba(0,0,0,0.06); backdrop-filter: blur(6px); }
    h1 { margin: 0 0 6px; font-size: clamp(22px, 3.4vmin, 32px); }
    p { margin: .5em 0; line-height: 1.8; color: #5b6470; }

    @media (prefers-reduced-motion: reduce) {
      .card { transition: none; }
    }
  </style>
</head>
<body>
  <!-- 水平面リップル用キャンバス。data-* でふるまい調整可能 -->
<canvas
  id="pond"
  class="pond"
  aria-hidden="true"
  data-drop-rate="1.0"          <!-- スケジュールされたタイミングでは必ず落とす -->
  data-min-interval="700"       <!-- 次の雨までの最短間隔(ms)を広げる -->
  data-max-interval="2400"      <!-- 最長間隔(ms)を広げて“間”にゆらぎを出す -->
  data-ripple-speed="0.55"      <!-- 波紋の広がりを遅く（0.45〜0.7の範囲でお好み） -->
  data-ripple-lifespan="3600"   <!-- 波紋の寿命を延ばして“ゆっくり感”を強調 -->
  data-ripple-width="1.1"
  data-ripple-max="80"
  data-multi-waves="true"
  data-splash-dot="true"
  data-parallax="0.02"
></canvas>

  <!-- 前景デモ。必要なければ削除OK -->
  <main class="content">
    <section class="card" role="region" aria-label="静穏の雨粒｜水平面リップル（トップビュー）">
      <h1>静穏の雨粒｜水平面リップル（トップビュー）</h1>
      <p>とっておきのおこだわり、あります。</p>
    </section>
  </main>

  <script>
    (function(){
      const canvas = document.getElementById('pond');
      const ctx = canvas.getContext('2d');
      const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // 設定（data-* で上書き）
      const cfg = {
        dropRate: parseFloat(canvas.dataset.dropRate || 0.9),        // 雨の出現しやすさ（0.0〜1.0）
        minInterval: parseInt(canvas.dataset.minInterval || 280, 10), // 連続ドロップの最短間隔(ms)
        maxInterval: parseInt(canvas.dataset.maxInterval || 900, 10), // 連続ドロップの最長間隔(ms)
        rippleSpeed: parseFloat(canvas.dataset.rippleSpeed || 1.0),   // 波紋の拡大速度係数
        rippleWidth: parseFloat(canvas.dataset.rippleWidth || 1.1),   // 波紋の線幅（px 基準）
        rippleLifespan: parseInt(canvas.dataset.rippleLifespan || 2400, 10), // 波紋が消えるまでのms
        rippleMax: parseInt(canvas.dataset.rippleMax || 80, 10),      // 同時存在する最大波紋数
        multiWaves: (canvas.dataset.multiWaves || 'true') === 'true', // 複数の同心円を描くか
        splashDot: (canvas.dataset.splashDot || 'true') === 'true',   // 着水点の点を描くか
        parallax: parseFloat(canvas.dataset.parallax || 0.02),        // わずかな視差（カーソルに反応）
      };

      // サイズ・座標
      let W, H, ripples = [], lastDropAt = 0, targetNext = 0, mouse = {x:0.5, y:0.5};
      function resize(){
        W = canvas.width  = Math.floor(innerWidth  * DPR);
        H = canvas.height = Math.floor(innerHeight * DPR);
        canvas.style.width = innerWidth + 'px';
        canvas.style.height = innerHeight + 'px';
      }

      // 波紋オブジェクト
      function spawnRipple(x, y){
        const now = performance.now();
        const life = cfg.rippleLifespan * (0.85 + Math.random()*0.3); // 少しばらつき
const speed = (0.08 + Math.random()*0.08) * cfg.rippleSpeed; // 半径増加( px/ms )
        const stroke = getComputedStyle(document.documentElement).getPropertyValue('--ripple-stroke').trim() || '#5d6b7a';
        const highlight = getComputedStyle(document.documentElement).getPropertyValue('--ripple-highlight').trim() || '#5d6b7a22';
        ripples.push({ x, y, born: now, life, speed, stroke, highlight });
        if (ripples.length > cfg.rippleMax) ripples.shift();
      }

      // ランダムな雨を落とす
      function maybeRain(now){
        if (now < targetNext) return;
        if (Math.random() <= cfg.dropRate){
          // 視差でわずかに中心寄りにオフセット（上から覗く立体感の演出）
          const px = (Math.random()*0.8 + 0.1) * W + (mouse.x - 0.5) * cfg.parallax * W;
          const py = (Math.random()*0.8 + 0.1) * H + (mouse.y - 0.5) * cfg.parallax * H;
          spawnRipple(px, py);
        }
        targetNext = now + (cfg.minInterval + Math.random()*(cfg.maxInterval - cfg.minInterval));
      }

      // トレイル（残像）
      function fade(){
        const t = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--trail-opacity') || '0.18');
        // 上から下へ、ごく薄い水色グラデーションのベールをかける
        const g = ctx.createLinearGradient(0, 0, 0, H);
        g.addColorStop(0.00, `rgba(244,246,248,${t})`); // #f4f6f8
        g.addColorStop(0.70, `rgba(244,246,248,${t})`);
        g.addColorStop(0.80, `rgba(232,236,239,${t})`); // #e8ecef
        g.addColorStop(0.90, `rgba(197,204,210,${t})`); // #c5ccd2
        g.addColorStop(1.00, `rgba(128,128,128,${t})`); // #808080
        ctx.fillStyle = g;
        ctx.fillRect(0,0,W,H);
      }

      // 波紋描画
      function drawRipples(now){
        const lwBase = cfg.rippleWidth * DPR;
        for (let i = ripples.length - 1; i >= 0; i--) {
          const r = ripples[i];
          const age = now - r.born;
          const k = age / r.life; // 0→1
          if (k >= 1){ ripples.splice(i,1); continue; }

          const radius = Math.max(0.5, age * r.speed * DPR);
          const alpha = (1 - k) * 0.6; // 徐々に薄く

          // 外側の主リップル
          ctx.beginPath();
          ctx.lineWidth = lwBase * (1 - k*0.5);
          ctx.strokeStyle = withAlpha(r.stroke, alpha);
          ctx.arc(r.x, r.y, radius, 0, Math.PI*2);
          ctx.stroke();

          // 内側の薄い光彩（任意）
          if (k < 0.85) {
            ctx.beginPath();
            ctx.lineWidth = lwBase * 0.6 * (1 - k);
            ctx.strokeStyle = withAlpha(r.highlight, alpha * 0.7);
            ctx.arc(r.x, r.y, Math.max(0.5, radius*0.65), 0, Math.PI*2);
            ctx.stroke();
          }

          // 着水点の微小な点（任意）
          if (cfg.splashDot && k < 0.15) {
            ctx.beginPath();
            ctx.fillStyle = withAlpha(r.stroke, Math.min(0.55, alpha+0.15));
            ctx.arc(r.x, r.y, 1.2*DPR, 0, Math.PI*2);
            ctx.fill();
          }
        }
      }

      function withAlpha(color, a){
        // #rrggbb or rgba() → rgba(r,g,b,a)
        if (color.startsWith('#')){
          const hex = color.replace('#','');
          const bigint = parseInt(hex.length===3 ? hex.split('').map(c=>c+c).join('') : hex, 16);
          const r = (bigint >> 16) & 255;
          const g = (bigint >> 8) & 255;
          const b = bigint & 255;
          return `rgba(${r},${g},${b},${a})`;
        }
        if (color.startsWith('rgba')) return color.replace(/rgba\(([^)]+)\)/, (m,vals)=>`rgba(${vals.split(',').slice(0,3).join(',')},${a})`);
        if (color.startsWith('rgb')) return color.replace(/rgb\(([^)]+)\)/, (m,vals)=>`rgba(${vals},${a})`);
        return color;
      }

      // ループ
      let rafId=null;
      function loop(now){
        fade();
        drawRipples(now);
        maybeRain(now);
        rafId = requestAnimationFrame(loop);
      }

      // 入出力
      function onVisibility(){
        if (document.hidden){ if (rafId) cancelAnimationFrame(rafId); rafId=null; }
        else if (!reduceMotion){ rafId = requestAnimationFrame(loop); }
      }
      function onPointer(e){
        const rect = canvas.getBoundingClientRect();
        mouse.x = ( (e.clientX - rect.left) / rect.width );
        mouse.y = ( (e.clientY - rect.top) / rect.height );
        // クリックで任意に波紋を追加（デモ用。不要ならコメントアウト）
        if (e.type === 'pointerdown') {
          spawnRipple((mouse.x)*W, (mouse.y)*H);
        }
      }

      // 初期化
      resize();
      window.addEventListener('resize', resize, {passive:true});
      document.addEventListener('visibilitychange', onVisibility);
      canvas.addEventListener('pointermove', onPointer, {passive:true});
      canvas.addEventListener('pointerdown', onPointer);

      if (!reduceMotion) rafId = requestAnimationFrame(loop);
      else fade(); // 1フレームだけ塗って終了

      // 外部制御 API（任意）
      window.Pond = {
        setRate(v){ cfg.dropRate = clamp(parseFloat(v),0,1); },
        setSpeed(v){ cfg.rippleSpeed = clamp(parseFloat(v),0.2,2.0); },
        setWidth(v){ cfg.rippleWidth = clamp(parseFloat(v),0.2,4.0); },
        setLifespan(ms){ cfg.rippleLifespan = clamp(parseInt(ms||0,10),400,6000); },
        spawn(x=0.5,y=0.5){ spawnRipple(x*W,y*H); },
      };

      function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
    })();
  </script>
</body>
</html>

