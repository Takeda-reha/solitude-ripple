<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>静穏の雨粒背景（抽象｜線と点）</title>
  <style>
:root {
  /* 背景（body 側の var(--bg-gradient) は表示されません。参考/バックアップ用として残してOK） */
  --bg-gradient: linear-gradient(
    180deg,
    #f4f6f8 0%,   /* 0%〜70% ほぼ白に近い薄いグレー */
    #f4f6f8 70%,
    #e8ecef 80%,  /* 70%〜80% 少しだけ濃いグレー */
    #c5ccd2 90%,  /* 80%〜90% 中間グレー寄り */
    #808080 100%  /* 90%〜100% 最終目標の #808080 */
  );

  /* ★ 雨＝最初のグレー（線・点） */
  --drop:   #5d6b7a;
  --ripple: #5d6b7a22;

  --opacity: 0.18;  /* 残像フェード */
  /* ↓ いまはキャンバス側で段階グラデーションを描くので未使用。残してOK */
  --fade-rgb: 0,0,0;

  --density: 0.75;
  --speed: 2.0;
  --line-ratio: 0.55;
  --blur: 0.0;
}


html, body {
  height: 100%;
  margin: 0;
  background: var(--bg-gradient);
  color: #222;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial,
               "Hiragino Kaku Gothic ProN", Meiryo, "Noto Sans JP", sans-serif;
}

    /* 背景キャンバスは全面固定（セクションが増えてもOK） */
    .rain-layer {
  position: fixed;
  inset: 0;
  z-index: 0;   /* ← -1 から 0 に変更 */
  filter: blur(var(--blur));
  }


    /* デモ用の前景（サイトの実コンテンツ想定） */
    .content {
      position: relative;
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 8vmin 4vmin;
    }

    .card {
      max-width: 880px;
      width: min(92vw, 880px);
      background: #ffffffd9;
      backdrop-filter: blur(6px);
      border: 1px solid #e6e8eb;
      border-radius: 20px;
      padding: clamp(20px, 4vmin, 40px);
      box-shadow: 0 20px 40px rgba(0,0,0,0.06);
    }

    h1 { font-size: clamp(22px, 3.5vmin, 32px); margin: 0 0 8px; }
    p { line-height: 1.8; margin: 0.5em 0; }
    .muted { color: #5b6470; }

    /* 動きの少ない設定を希望するユーザーを尊重 */
    @media (prefers-reduced-motion: reduce) {
      .card { transition: none; }
    }
  </style>
</head>
<body>
  <!-- 背景キャンバス：data-* で簡易カスタマイズ可能 -->
  <canvas
    id="rainCanvas"
    class="rain-layer"
    aria-hidden="true"
    data-density="0.8"      
    data-speed="1.0"        
    data-line-ratio="0.55"  
    data-max-drops="240"    
    data-dot-size="1.2"     
    data-line-length="16"   
    data-line-thickness="1" 
    data-ripple="true"      
  ></canvas>

  <!-- 前景のダミーコンテンツ（実装時は置き換え） -->
<!--
<main class="content">
  <section class="card" role="region" aria-label="静穏の雨粒背景デモ">
    <h1>静穏の雨粒背景（線と点の抽象アニメーション）</h1>
    <p class="muted">背景は <strong>窓に落ちる雨のリズム</strong> を、線と点だけでミニマルに表現しています。色・密度・スピードはCSS変数やdata属性で調整できます。</p>
    <p class="muted">アクセシビリティ配慮として <code>prefers-reduced-motion</code> に従い、ユーザーが「動きを減らす」を有効にしている場合はアニメーションを停止します。</p>
  </section>
</main>
-->

  <script>
    (function() {
      const canvas = document.getElementById('rainCanvas');
      const ctx = canvas.getContext('2d');

      // DPR（高解像度ディスプレイ）対応
      const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

      // 動きを減らす設定の尊重
      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // データ属性による上書き可能パラメータ
      const cfg = {
        density: parseFloat(canvas.dataset.density || getCSS('--density', 0.75)),
        speed: parseFloat(canvas.dataset.speed || getCSS('--speed', 1.0)),
        lineRatio: parseFloat(canvas.dataset.lineRatio || getCSS('--line-ratio', 0.55)),
        maxDrops: parseInt(canvas.dataset.maxDrops || 220, 10),
        dotSize: parseFloat(canvas.dataset.dotSize || 1.2),
        lineLength: parseFloat(canvas.dataset.lineLength || 16),
        lineThickness: parseFloat(canvas.dataset.lineThickness || 1),
        ripple: (canvas.dataset.ripple || 'true') === 'true',
      };

      // CSS変数から値を取得（フォールバック付き）
      function getCSS(varName, fallback) {
        const v = getComputedStyle(document.documentElement).getPropertyValue(varName);
        const n = parseFloat(v.trim());
        return Number.isFinite(n) ? n : fallback;
      }

      // サイズ設定
      let W, H, drops = [], ripples = [];
      function resize() {
        W = canvas.width = Math.floor(innerWidth * DPR);
        H = canvas.height = Math.floor(innerHeight * DPR);
        canvas.style.width = innerWidth + 'px';
        canvas.style.height = innerHeight + 'px';
        // 画面サイズに応じて必要数を調整
        const base = Math.floor((W * H) / (800 * 600)); // 面積スケーリング基準
        const targetCount = Math.min(cfg.maxDrops, Math.floor(140 * cfg.density * Math.max(1, base)));
        resetPool(targetCount);
      }

      // 雨粒オブジェクト生成
      function newDrop() {
       const isLine = Math.random() < cfg.lineRatio;

      // ランダムを維持しつつ速めにバイアス
       const base = isLine ? 230 : 170;            // px/sec の基準値（従来より速め）
       const u = Math.pow(Math.random(), 0.6);     // 0〜1（高めに偏らせる）
       const speed = base * (0.8 + u * 1.4) * cfg.speed; // ≒0.8〜2.2倍の幅
       const vy = speed / 60;                      // 1フレーム当たり
       const ay = (isLine ? 18 : 12) / 60 * cfg.speed;    // 疑似重力（加速度）

       const len = isLine ? Math.max(12, speed * 0.06) : 0; // 速いほど長い筋に

       return {
         x: Math.random() * W,
         y: - (len || cfg.dotSize * 2) - Math.random() * 80, // 画面上から生まれる
         vy,
         ay,
         len,
         thick: cfg.lineThickness * (0.7 + Math.random() * 0.6),
         type: isLine ? 'line' : 'dot',
         alpha: 0.45 + Math.random() * 0.25,
       };
     }


      function resetPool(target) {
        const current = drops.length;
        if (current < target) {
          for (let i = current; i < target; i++) drops.push(newDrop());
        } else if (current > target) {
          drops.length = target;
        }
      }

      function addRipple(x, y) {
        if (!cfg.ripple) return;
        ripples.push({ x, y, r: 0, alpha: 0.18 });
        if (ripples.length > 32) ripples.shift(); // 上限
      }

function step() {
  // 背景フェード（残像を少し残す）を「上70%ほぼ白 → 下端 #808080」の段階グラデに
  const opacity = getCSS('--opacity', 0.22);

  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0.00, `rgba(244,246,248,${opacity})`); // #f4f6f8 ほぼ白
  g.addColorStop(0.70, `rgba(244,246,248,${opacity})`); // 70% まで維持
  g.addColorStop(0.80, `rgba(232,236,239,${opacity})`); // #e8ecef
  g.addColorStop(0.90, `rgba(197,204,210,${opacity})`); // #c5ccd2
  g.addColorStop(1.00, `rgba(128,128,128,${opacity})`); // #808080

  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  // 雨（線・点）の色＝CSS変数 --drop を反映（= #5d6b7a）
  const dropColor = getComputedStyle(document.documentElement)
                      .getPropertyValue('--drop').trim() || '#5d6b7a';
  ctx.strokeStyle = dropColor;
  ctx.fillStyle = dropColor;


        // 雨粒の描画
        for (let i = 0; i < drops.length; i++) {
          const d = drops[i];

        // ループ内（雨粒の描画まわり）で:
          d.vy += d.ay || 0;          // 疑似重力で少しずつ加速
          d.y += d.vy * DPR; // DPRに合わせた移動

          ctx.globalAlpha = d.alpha;
          if (d.type === 'line') {
            ctx.lineWidth = d.thick;
            ctx.beginPath();
            ctx.moveTo(d.x, d.y - d.len);
            ctx.lineTo(d.x, d.y);
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.arc(d.x, d.y, cfg.dotSize, 0, Math.PI * 2);
            ctx.fill();
          }

          // 画面下に到達したら上部に戻す＋リップル
          if (d.y - (d.len || 0) > H) {
            if (cfg.ripple) addRipple(d.x, H - 4 * DPR);
            drops[i] = newDrop();     // 速度や長さもリセットして再生成
            drops[i].x = Math.random() * W;
          }
        }

        // リップル描画（薄く広がって消える）
        if (cfg.ripple && ripples.length) {
          for (let i = ripples.length - 1; i >= 0; i--) {
            const r = ripples[i];
            r.r += 0.8 * DPR;
            r.alpha *= 0.985;
            if (r.alpha < 0.008) { ripples.splice(i, 1); continue; }
            ctx.beginPath();
            ctx.globalAlpha = r.alpha;
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--ripple').trim() || '#5d6b7a22';
            ctx.lineWidth = 1 * DPR;
            ctx.arc(r.x, r.y, r.r, 0, Math.PI);
            ctx.stroke();
          }
        }

        ctx.globalAlpha = 1;
      }

      let rafId = null;
      function loop() {
        step();
        rafId = requestAnimationFrame(loop);
      }

      // タブ非表示時は停止して省電力
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          if (rafId) cancelAnimationFrame(rafId);
          rafId = null;
        } else if (!reduceMotion) {
          rafId = requestAnimationFrame(loop);
        }
      });

      // 初期化
      resize();
      window.addEventListener('resize', resize, { passive: true });

      if (!reduceMotion) {
        rafId = requestAnimationFrame(loop);
      } else {
        // 動きを減らすユーザー向けに1フレームだけ描いて終了
        step();
      }

      // 外部から簡単に調整できるようにAPIを公開（任意）
      window.RainBackdrop = {
        setDensity(v) { cfg.density = clamp(parseFloat(v), 0.1, 2.0); resize(); },
        setSpeed(v) { cfg.speed = clamp(parseFloat(v), 0.2, 2.0); },
        setLineRatio(v) { cfg.lineRatio = clamp(parseFloat(v), 0, 1); },
        setColors({ bgStart, bgEnd, drop, ripple }) {
          if (bgStart) document.documentElement.style.setProperty('--bg-start', bgStart);
          if (bgEnd) document.documentElement.style.setProperty('--bg-end', bgEnd);
          if (drop) document.documentElement.style.setProperty('--drop', drop);
          if (ripple) document.documentElement.style.setProperty('--ripple', ripple);
        },
        pause() { if (rafId) cancelAnimationFrame(rafId); rafId = null; },
        play() { if (!rafId && !reduceMotion) rafId = requestAnimationFrame(loop); },
      };

      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
    })();
  </script>
</body>
</html>
