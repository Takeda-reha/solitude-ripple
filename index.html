<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>静穏の雨粒背景（抽象｜線と点）</title>

  <style>
:root {
  --bg-gradient: linear-gradient(
    180deg,
    #f4f6f8 0%,
    #f4f6f8 70%,
    #e8ecef 80%,
    #c5ccd2 90%,
    #808080 100%
  );
  --drop:   #5d6b7a;
  --ripple: #5d6b7a22;
  --opacity: 0.18;
  --fade-rgb: 0,0,0;
  --density: 0.75;
  --speed: 2.0;
  --line-ratio: 0.55;
  --blur: 0.0;
}

html, body {
  height: 100%;
  margin: 0;
  background: var(--bg-gradient);
  color: #222;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial,
               "Hiragino Kaku Gothic ProN", Meiryo, "Noto Sans JP", sans-serif;
}

/* 背景キャンバスは全面固定 */
.rain-layer {
  position: fixed;
  inset: 0;
  z-index: 0;
  filter: blur(var(--blur));
}

/* 前景（テキスト領域） */
.content {
  position: relative;
  min-height: 100%;
  display: flex;
  justify-content: center;
  align-items: flex-start; /* 中央より少し上 */
  padding: 12vh 4vmin 8vmin;
  text-align: center;
}

.card {
  max-width: 880px;
  width: min(92vw, 880px);
  background: rgba(255, 255, 255, 0.45);
  backdrop-filter: none;
  -webkit-backdrop-filter: none;
  box-shadow: none;
  border: 1px solid transparent;
  border-radius: 20px;
  padding: clamp(20px, 4vmin, 40px);
}

h1 { font-size: clamp(22px, 3.5vmin, 32px); margin: 0 0 8px; }
p  { line-height: 1.8; margin: 0.5em 0; }

.content .card { color: rgb(51 51 51); }
.content .card a { color: #2f3a44; }
.content .card p { margin: 0 0 0.5em; }
.content .card p + p { margin-top: 1.8em; }

/* 画面下中央の鳥居アイコン（＝リンク） */
.entrance-link {
  position: fixed;
  bottom: 6vh;
  left: 50%;
  transform: translateX(-50%);
  z-index: 50;        /* キャンバスより前面 */
  text-align: center;
}

.torii-icon {
  width: 96px;        /* 好みで 80〜128px などに */
  height: auto;
  opacity: 0.9;
  transition: transform 0.25s ease, opacity 0.25s ease;
  cursor: pointer;
  user-select: none;
  -webkit-user-drag: none;
}
.torii-icon:hover {
  transform: translateY(-4px) scale(1.05);
  opacity: 1.0;
}

/* 動きを減らす設定を尊重 */
@media (prefers-reduced-motion: reduce) {
  .card { transition: none; }
}

.entrance-link { z-index: 9999; }
.torii-icon { display: block; }

  </style>
</head>

<body>
  <!-- 背景キャンバス -->
  <canvas
    id="rainCanvas"
    class="rain-layer"
    aria-hidden="true"
    data-density="0.8"
    data-speed="1.0"
    data-line-ratio="0.55"
    data-max-drops="240"
    data-dot-size="1.2"
    data-line-length="16"
    data-line-thickness="1"
    data-ripple="true"
  ></canvas>

  <!-- 前景テキスト -->
  <main class="content">
    <section class="card">
      <p>有給休暇を取ったある日、わたしは車を走らせていた。<br>
      雨が降るなか、立ち寄ったケンタッキーフライドチキンで、<br>
      チキンとポテトを買い、車に戻ってラジオをかけて食べた。</p>

      <p>誰にも気を遣わず、何の義務もなく、<br>
      ただ雨とラジオの音とチキンの香りに包まれた時間。<br>
      誰かと話したわけでも、特別なイベントがあったわけでもない。<br>
      それでもわたしは驚くほど満たされた気持ちになった。</p>
    </section>
  </main>

  <!-- 下中央の鳥居アイコン＝リンク（画像のみ・文字なし） -->
  <div class="entrance-link">
  <a href="main.html" aria-label="メインページへ">
    <img src="https://takeda-reha.github.io/solitude-ripple/torii.png?v=1"
         alt="メインページへ" class="torii-icon">
  </a>
</div>


  <script>
    (function() {
      const canvas = document.getElementById('rainCanvas');
      const ctx = canvas.getContext('2d');
      const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      const cfg = {
        density: parseFloat(canvas.dataset.density || getCSS('--density', 0.75)),
        speed: parseFloat(canvas.dataset.speed || getCSS('--speed', 1.0)),
        lineRatio: parseFloat(canvas.dataset.lineRatio || getCSS('--line-ratio', 0.55)),
        maxDrops: parseInt(canvas.dataset.maxDrops || 220, 10),
        dotSize: parseFloat(canvas.dataset.dotSize || 1.2),
        lineLength: parseFloat(canvas.dataset.lineLength || 16),
        lineThickness: parseFloat(canvas.dataset.lineThickness || 1),
        ripple: (canvas.dataset.ripple || 'true') === 'true',
      };

      function getCSS(varName, fallback) {
        const v = getComputedStyle(document.documentElement).getPropertyValue(varName);
        const n = parseFloat(v.trim());
        return Number.isFinite(n) ? n : fallback;
      }

      let W, H, drops = [], ripples = [];
      function resize() {
        W = canvas.width = Math.floor(innerWidth * DPR);
        H = canvas.height = Math.floor(innerHeight * DPR);
        canvas.style.width = innerWidth + 'px';
        canvas.style.height = innerHeight + 'px';
        const base = Math.floor((W * H) / (800 * 600));
        const targetCount = Math.min(cfg.maxDrops, Math.floor(140 * cfg.density * Math.max(1, base)));
        resetPool(targetCount);
      }

      function newDrop() {
        const isLine = Math.random() < cfg.lineRatio;
        const base = isLine ? 230 : 170;
        const u = Math.pow(Math.random(), 0.6);
        const speed = base * (0.8 + u * 1.4) * cfg.speed;
        const vy = speed / 60;
        const ay = (isLine ? 18 : 12) / 60 * cfg.speed;
        const len = isLine ? Math.max(12, speed * 0.06) : 0;
        return {
          x: Math.random() * W,
          y: -(len || cfg.dotSize * 2) - Math.random() * 80,
          vy, ay, len,
          thick: cfg.lineThickness * (0.7 + Math.random() * 0.6),
          type: isLine ? 'line' : 'dot',
          alpha: 0.45 + Math.random() * 0.25,
        };
      }

      function resetPool(target) {
        const current = drops.length;
        if (current < target) for (let i = current; i < target; i++) drops.push(newDrop());
        else if (current > target) drops.length = target;
      }

      function addRipple(x, y) {
        if (!cfg.ripple) return;
        ripples.push({ x, y, r: 0, alpha: 0.18 });
        if (ripples.length > 32) ripples.shift();
      }

      function step() {
        const opacity = getCSS('--opacity', 0.22);
        const g = ctx.createLinearGradient(0, 0, 0, H);
        g.addColorStop(0.00, `rgba(244,246,248,${opacity})`);
        g.addColorStop(0.70, `rgba(244,246,248,${opacity})`);
        g.addColorStop(0.80, `rgba(232,236,239,${opacity})`);
        g.addColorStop(0.90, `rgba(197,204,210,${opacity})`);
        g.addColorStop(1.00, `rgba(128,128,128,${opacity})`);
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);

        const dropColor = getComputedStyle(document.documentElement).getPropertyValue('--drop').trim() || '#5d6b7a';
        ctx.strokeStyle = dropColor;
        ctx.fillStyle = dropColor;

        for (let i = 0; i < drops.length; i++) {
          const d = drops[i];
          d.vy += d.ay || 0;
          d.y += d.vy * DPR;

          ctx.globalAlpha = d.alpha;
          if (d.type === 'line') {
            ctx.lineWidth = d.thick;
            ctx.beginPath();
            ctx.moveTo(d.x, d.y - d.len);
            ctx.lineTo(d.x, d.y);
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.arc(d.x, d.y, cfg.dotSize, 0, Math.PI * 2);
            ctx.fill();
          }

          if (d.y - (d.len || 0) > H) {
            if (cfg.ripple) addRipple(d.x, H - 4 * DPR);
            drops[i] = newDrop();
            drops[i].x = Math.random() * W;
          }
        }

        if (cfg.ripple && ripples.length) {
          for (let i = ripples.length - 1; i >= 0; i--) {
            const r = ripples[i];
            r.r += 0.8 * DPR;
            r.alpha *= 0.985;
            if (r.alpha < 0.008) { ripples.splice(i, 1); continue; }
            ctx.beginPath();
            ctx.globalAlpha = r.alpha;
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--ripple').trim() || '#5d6b7a22';
            ctx.lineWidth = 1 * DPR;
            ctx.arc(r.x, r.y, r.r, 0, Math.PI);
            ctx.stroke();
          }
        }

        ctx.globalAlpha = 1;
      }

      let rafId = null;
      function loop() { step(); rafId = requestAnimationFrame(loop); }

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) { if (rafId) cancelAnimationFrame(rafId); rafId = null; }
        else if (!reduceMotion) { rafId = requestAnimationFrame(loop); }
      });

      resize();
      window.addEventListener('resize', resize, { passive: true });
      if (!reduceMotion) { rafId = requestAnimationFrame(loop); } else { step(); }

      window.RainBackdrop = {
        setDensity(v) { cfg.density = clamp(parseFloat(v), 0.1, 2.0); resize(); },
        setSpeed(v) { cfg.speed = clamp(parseFloat(v), 0.2, 2.0); },
        setLineRatio(v) { cfg.lineRatio = clamp(parseFloat(v), 0, 1); },
        setColors({ bgStart, bgEnd, drop, ripple }) {
          if (bgStart) document.documentElement.style.setProperty('--bg-start', bgStart);
          if (bgEnd) document.documentElement.style.setProperty('--bg-end', bgEnd);
          if (drop) document.documentElement.style.setProperty('--drop', drop);
          if (ripple) document.documentElement.style.setProperty('--ripple', ripple);
        },
        pause() { if (rafId) cancelAnimationFrame(rafId); rafId = null; },
        play() { if (!rafId && !reduceMotion) rafId = requestAnimationFrame(loop); },
      };

      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
    })();
  </script>
</body>
</html>
